import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier

class Strategy:
    def __init__(self):
        self.name = "<teamname> - <strategyname>"
        self.description = "A strategy using EMA, RSI, and returns to predict buy/sell/hold."
        self.model = RandomForestClassifier(n_estimators=200, random_state=42)
        self.lookahead = 5
        self.threshold = 0.002
        self.confidence = 0.6
        self.initial_capital = 10000000  # 10 million dollars
        self.current_capital = self.initial_capital
        self.position = 0  # 0 means no position (in cash), 1 means holding a position

    def add_features(self, df: pd.DataFrame) -> pd.DataFrame:
        # --- Return --- 
        df['return'] = df['close'].pct_change()

        # --- EMA --- (Exponential Moving Average)
        df['ema20'] = df['close'].ewm(span=20, adjust=False).mean()
        df['ema50'] = df['close'].ewm(span=50, adjust=False).mean()

        # --- RSI (14) --- (Relative Strength Index)
        delta = df['close'].diff()
        gain = np.where(delta > 0, delta, 0)
        loss = np.where(delta < 0, -delta, 0)
        avg_gain = pd.Series(gain).rolling(14).mean()
        avg_loss = pd.Series(loss).rolling(14).mean()
        rs = avg_gain / (avg_loss + 1e-9)  # Add small constant to avoid division by zero
        df['rsi14'] = 100 - (100 / (1 + rs))

        # --- Volatility --- (Rolling standard deviation of returns)
        df['vol'] = df['return'].rolling(20).std()

        return df.dropna()

    def label_data(self, df: pd.DataFrame) -> pd.DataFrame:
        df.loc[:, 'future_return'] = df['close'].shift(-self.lookahead) / df['close'] - 1
        def lab(r):
            if r > self.threshold: return "BUY"
            elif r < -self.threshold: return "SELL"
            else: return "HOLD"
        df.loc[:, 'label'] = df['future_return'].apply(lab)
        return df.dropna()

    def fit(self, train_df: pd.DataFrame) -> None:
        # Prepare data for training
        train_df = self.label_data(self.add_features(train_df))
        features = ['return','ema20','ema50','rsi14','vol']
        X_train, y_train = train_df[features], train_df['label']
        
        # Train the model
        self.model.fit(X_train, y_train)

    def predict(self, test_df: pd.DataFrame) -> pd.Series:
        # Prepare the features for prediction
        test_df = self.add_features(test_df)
        features = ['return','ema20','ema50','rsi14','vol']
        X_test = test_df[features]

        # Predict labels directly (BUY, SELL, HOLD)
        predictions = self.model.predict(X_test)

        # Generate trading signals based on predictions
        signals = []
        for prediction in predictions:
            if prediction == "BUY" and self.position == 0:  # Buy if no current position
                signals.append("BUY")
                self.position = 1  # Now holding a position
                self.current_capital = 0  # All-in, no cash left
            elif prediction == "SELL" and self.position == 1:  # Sell if holding a position
                signals.append("SELL")
                self.position = 0  # No position, in cash
                self.current_capital = self.initial_capital  # Return to initial capital (all cash)
            else:  # Hold if no action needed
                signals.append("HOLD")
        
        # Return the signals as a pandas Series with the same index as test_df
        return pd.Series(signals, index=test_df.index)
    
# ...existing code...

def backtest_equity_and_sharpe(test_df, signals, initial_capital=10000000):
    position = 0
    cash = initial_capital
    asset = 0
    equity_curve = []

    for i in range(len(signals)):
        price = test_df.iloc[i]['close']
        signal = signals.iloc[i]
        # Buy
        if signal == "BUY" and position == 0:
            asset = cash / price
            cash = 0
            position = 1
        # Sell
        elif signal == "SELL" and position == 1:
            cash = asset * price
            asset = 0
            position = 0
        # Equity update
        equity = cash if position == 0 else asset * price
        equity_curve.append(equity)

    final_equity = equity_curve[-1] if equity_curve else initial_capital
    returns = np.diff(equity_curve) / equity_curve[:-1] if len(equity_curve) > 1 else np.array([0])
    sharpe = (np.mean(returns) / (np.std(returns) + 1e-9)) * np.sqrt(252*24*60) if len(returns) > 1 else 0
    return final_equity, sharpe





# Create the strategy instance
strategy = Strategy()

# Train the model on the training data
train_df = pd.read_csv("train1.csv")
strategy.fit(train_df)

# Generate predictions on the test data
test_df = pd.read_csv("random_sample_test.csv")
predictions = strategy.predict(test_df)

# View predictions (trading signals)
print(predictions.head())

# ...existing code...

# Generate predictions on the test data
test_df = pd.read_csv("random_sample_test.csv")
predictions = strategy.predict(test_df)

# Save predictions (trading signals) to CSV
predictions.to_csv("predicted_signals.csv", header=True, index=False)
print("✅ Predictions saved to predicted_signals.csv")


# ...existing code...

# Save predictions (trading signals) to CSV
predictions.to_csv("predicted_signals.csv", header=True, index=False)
print("✅ Predictions saved to predicted_signals.csv")

# Calculate and print final equity and Sharpe ratio
final_equity, sharpe = backtest_equity_and_sharpe(test_df.reset_index(drop=True), predictions.reset_index(drop=True))
print(f"Final equity: {final_equity:.2f}")
print(f"Sharpe ratio: {sharpe:.4f}")